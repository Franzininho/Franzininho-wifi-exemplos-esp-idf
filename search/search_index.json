{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Primeiros Passos Este documento tem como objetivo ajud\u00e1-lo a configurar o ESP-IDF (Espressif IoT Development Framework) para trabalhar com a Franzininho WiFi que usa o ESP32-S2 da Espressif. Ao final, faremos um exemplo simples para compilar, gravar e monitorar usando o ESP-IDF, assim, garantiremos que tudo estar\u00e1 funcionando. Introdu\u00e7\u00e3o Para essa configura\u00e7\u00e3o, vamos instalar o ESP-IDF e us\u00e1-lo atrav\u00e9s de linha de comando. Caso voc\u00ea queira usar o IDF integrado a ambientes de desenvolvimento integrado (IDE) como VScode e Eclipse, confira os seguintes links: Eclipse Plugin VS Code Extension Voc\u00ea poder\u00e1 instalar o ESP-IDF no seu sistema operacional preferido (Linux, Windows, macOS). Para a experi\u00eancia completa, voc\u00ea precisar\u00e1 de uma placa Franzininho WiFi, Computador: com Windows, Linux ou macOS Passo 1 - Instala\u00e7\u00e3o dos pr\u00e9-requisitos Algumas ferramentas precisam ser instaladas no computador antes de prosseguir para as pr\u00f3ximas etapas. Siga os links abaixo para obter as instru\u00e7\u00f5es para o seu sistema operacional: Windows Linux Mac OS \u00c9 muito importante a instala\u00e7\u00e3o de todos os pr\u00e9-requisitos. Passo 2 - Instala\u00e7\u00e3o do ESP-IDF Nessa etapa vamos instalar o ESP-IDF e conjunto de ferramentas e bibliotecas. Vamos usar o c\u00f3digo mantido pela Espressif no reposit\u00f3rio do ESP-IDF O ESP-IDF \u00e9 o framework oficial da Espressif para o desenvolvimento de aplica\u00e7\u00f5es parar toda a fam\u00edlia ESP32. O procedimento apresentado aqui servir\u00e1 para trabalhar com toda a fam\u00edlia ESP32. Por\u00e9m, vamos dar foco ao ESP32-S2 que \u00e9 usado na Franzininho WiFi. Linux e macOS Abra o terminal e execute: mkdir -p ~/esp cd ~/esp git clone --recursive https://github.com/espressif/esp-idf.git O ESP-IDF ser\u00e1 baixado no seguinte reposit\u00f3rio ~/esp/esp-idf . Windows Al\u00e9m de instalar as ferramentas, o ESP-IDF Tools Installer para Windows apresentado no passo 1 ele tamb\u00e9m baixa uma c\u00f3pia do ESP-IDF. Dessa forma voc\u00ea n\u00e3o precisar\u00e1 baixar o ESP-IDF agora, se j\u00e1 tiver baixado anteriormente junto aos pr\u00e9-requisitos. Se desejar fazer o download do ESP-IDF sem a ajuda do ESP-IDF Tools Installer, consulte estas instru\u00e7\u00f5es . Instalando O ESP-IDF e ferramentas Al\u00e9m do ESP-IDF, voc\u00ea tamb\u00e9m precisa instalar as ferramentas usadas pelo ESP-IDF, como compilador, depurador, pacotes Python, etc. Windows O ESP-IDF Tools Installer para Windows apresentado no passo 1 instala todas as ferramentas necess\u00e1rias. Se voc\u00ea deseja instalar as ferramentas sem a ajuda do ESP-IDF Tools Installer, abra o Prompt de Comando e siga estas etapas: cd %userprofile%\\esp\\esp-idf install.bat Ou no Windows PowerShell cd ~/esp/esp-idf ./install.ps1 Linux e macOS No Linux ou macOS h\u00e1 um script para instala\u00e7\u00e3o.Abra o terminal e execute: cd ~/esp/esp-idf ./install.sh Configurando as vari\u00e1veis de ambientes As ferramentas instaladas ainda n\u00e3o foram adicionadas \u00e0 vari\u00e1vel de ambiente PATH. Para tornar as ferramentas utiliz\u00e1veis na linha de comando, algumas vari\u00e1veis de ambiente devem ser definidas. ESP-IDF fornece alguns scripts que ajudam nesse processo. Windows O ESP-IDF Tools Installer para Windows cria um atalho \u201cESP-IDF Command Prompt\u201d no menu Iniciar. Este atalho abre o Prompt de Comando e configura todas as vari\u00e1veis de ambiente necess\u00e1rias. Voc\u00ea pode abrir este atalho e prosseguir para a pr\u00f3xima etapa. Caso n\u00e3o funcione e voc\u00ea precise configurar manualmente, execute os seguintes comandos: Prompt de Comando : %userprofile%\\esp\\esp-idf\\export.bat Windows PowerShell : .$HOME/esp/esp-idf/export.ps1 Linux e macOS No terminal execute: . $HOME/esp/esp-idf/export.sh Voc\u00ea precisa fazer isso toda vez que iniciar o terminal para usar o ESP-IDF. Passo 3 - Criando um novo projeto Agora que j\u00e1 temos as ferramentas instaladas, vamos fazer um exemplo para validar o funcionamento das mesmas. Vamos executar o exemplo blink que j\u00e1 vem no IDF. Copiando um projeto exemplo Vamos copiar o projeto blink para preservarmos o exemplo presente na pasta do IDF: Windows cd %userprofile%\\esp xcopy /e /i %IDF_PATH%\\examples\\get-started\\blink blink Linux e macOS cd ~/esp cp -r $IDF_PATH/examples/get-started/blink . Fique a vontade para testar os outros exemplos tamb\u00e9m. O sistema de compila\u00e7\u00e3o ESP-IDF n\u00e3o oferece suporte a espa\u00e7os nos caminhos para o ESP-IDF ou para projetos. Configura\u00e7\u00e3o Agora vamos configurar o target para qual ser\u00e1 compilado e j\u00e1 fazer uma configura\u00e7\u00e3o no menuconfig. No nosso caso vamos trabalhar com o ESP32-S2: Windows cd %userprofile%\\esp\\blink idf.py set-target esp32s2 idf.py menuconfig Linux e macOS cd ~/esp/blink idf.py set-target esp32s2 idf.py menuconfig Ser\u00e1 aberto o menuconfig: Acesse a op\u00e7\u00e3o Component config ---> Em seguida ESP System Settings ---> Agora selecione Channel for console output (Default: UART0) ---> E por fim, selecione (X) USB CDC: Salve(S), Enter, enter, Saia do menu(ESC) Essa configura\u00e7\u00e3o permitir\u00e1 que usemos a USB no pr\u00f3ximo upload. Sempre que iniciar um projeto novo fa\u00e7a essas configura\u00e7\u00e3o para que continue usando a USB como interface de programa\u00e7\u00e3o. Para mais detalhes acesse: Compilando o projeto em modo DFU A primeira compila\u00e7\u00e3o n\u00f3s vamos fazer usando o modo DFU, que j\u00e1 vem por padr\u00e3o no ESP32-S2 permitindo o upload atrav\u00e9s da USB: Para crie a imagem DFU: idf.py dfu A primeira compila\u00e7\u00e3o pode demorar um pouco. Da at\u00e9 pra ir pegar um caf\u00e9 ;) Ap\u00f3s a compila\u00e7\u00e3o, conecte a Franzininho WiFi no computador. Antes de fazermos o upload \u00e9 necess\u00e1rio entrar no modo DFU. Para entrar no modo DFU pressione as teclas na seguinte sequencia: pressione e segure a tecla BOOT pressione rapidamente e solte a tecla presente solte a tecla BOOT Dessa forma a placa entrar\u00e1 no modo DFU e poder\u00e1 receber o firmware atrav\u00e9s da USB. Para fazer a grava\u00e7\u00e3o, digite: idf.py dfu-flash Caso tenha permiss\u00e3o de acesso a porta USB, acesse esse link com as instru\u00e7\u00f5es de configura\u00e7\u00f5es Ap\u00f3s alguns segundos a placa estar\u00e1 gravada. Compila\u00e7\u00e3o, grava\u00e7\u00e3o e monitor em modo normal Agora voc\u00ea poder\u00e1 compilar, gravar e monitorar usando a porta USB. Esse processo \u00e9 id\u00eantico ao que fazemos para desenvolver com o ESP32: Compilar: idf.py build Gravar: idf.py -p PORT [-b BAUD] flash Monitorar: idf.py -p /dev/ttyUSB0 monitor Maravilha, voc\u00ea configurou o ambiente para trabalhar com o ESP-IDF. Caso queira trabalhar com a extens\u00e3o para VSCODE, confira o video:","title":"Primeiros passos"},{"location":"#primeiros-passos","text":"Este documento tem como objetivo ajud\u00e1-lo a configurar o ESP-IDF (Espressif IoT Development Framework) para trabalhar com a Franzininho WiFi que usa o ESP32-S2 da Espressif. Ao final, faremos um exemplo simples para compilar, gravar e monitorar usando o ESP-IDF, assim, garantiremos que tudo estar\u00e1 funcionando.","title":"Primeiros Passos"},{"location":"#introducao","text":"Para essa configura\u00e7\u00e3o, vamos instalar o ESP-IDF e us\u00e1-lo atrav\u00e9s de linha de comando. Caso voc\u00ea queira usar o IDF integrado a ambientes de desenvolvimento integrado (IDE) como VScode e Eclipse, confira os seguintes links: Eclipse Plugin VS Code Extension Voc\u00ea poder\u00e1 instalar o ESP-IDF no seu sistema operacional preferido (Linux, Windows, macOS). Para a experi\u00eancia completa, voc\u00ea precisar\u00e1 de uma placa Franzininho WiFi, Computador: com Windows, Linux ou macOS","title":"Introdu\u00e7\u00e3o"},{"location":"#passo-1-instalacao-dos-pre-requisitos","text":"Algumas ferramentas precisam ser instaladas no computador antes de prosseguir para as pr\u00f3ximas etapas. Siga os links abaixo para obter as instru\u00e7\u00f5es para o seu sistema operacional: Windows Linux Mac OS \u00c9 muito importante a instala\u00e7\u00e3o de todos os pr\u00e9-requisitos.","title":"Passo 1 - Instala\u00e7\u00e3o dos pr\u00e9-requisitos"},{"location":"#passo-2-instalacao-do-esp-idf","text":"Nessa etapa vamos instalar o ESP-IDF e conjunto de ferramentas e bibliotecas. Vamos usar o c\u00f3digo mantido pela Espressif no reposit\u00f3rio do ESP-IDF O ESP-IDF \u00e9 o framework oficial da Espressif para o desenvolvimento de aplica\u00e7\u00f5es parar toda a fam\u00edlia ESP32. O procedimento apresentado aqui servir\u00e1 para trabalhar com toda a fam\u00edlia ESP32. Por\u00e9m, vamos dar foco ao ESP32-S2 que \u00e9 usado na Franzininho WiFi.","title":"Passo 2 - Instala\u00e7\u00e3o do ESP-IDF"},{"location":"#linux-e-macos","text":"Abra o terminal e execute: mkdir -p ~/esp cd ~/esp git clone --recursive https://github.com/espressif/esp-idf.git O ESP-IDF ser\u00e1 baixado no seguinte reposit\u00f3rio ~/esp/esp-idf .","title":"Linux e macOS"},{"location":"#windows","text":"Al\u00e9m de instalar as ferramentas, o ESP-IDF Tools Installer para Windows apresentado no passo 1 ele tamb\u00e9m baixa uma c\u00f3pia do ESP-IDF. Dessa forma voc\u00ea n\u00e3o precisar\u00e1 baixar o ESP-IDF agora, se j\u00e1 tiver baixado anteriormente junto aos pr\u00e9-requisitos. Se desejar fazer o download do ESP-IDF sem a ajuda do ESP-IDF Tools Installer, consulte estas instru\u00e7\u00f5es .","title":"Windows"},{"location":"#instalando-o-esp-idf-e-ferramentas","text":"Al\u00e9m do ESP-IDF, voc\u00ea tamb\u00e9m precisa instalar as ferramentas usadas pelo ESP-IDF, como compilador, depurador, pacotes Python, etc.","title":"Instalando O ESP-IDF e ferramentas"},{"location":"#windows_1","text":"O ESP-IDF Tools Installer para Windows apresentado no passo 1 instala todas as ferramentas necess\u00e1rias. Se voc\u00ea deseja instalar as ferramentas sem a ajuda do ESP-IDF Tools Installer, abra o Prompt de Comando e siga estas etapas: cd %userprofile%\\esp\\esp-idf install.bat Ou no Windows PowerShell cd ~/esp/esp-idf ./install.ps1","title":"Windows"},{"location":"#linux-e-macos_1","text":"No Linux ou macOS h\u00e1 um script para instala\u00e7\u00e3o.Abra o terminal e execute: cd ~/esp/esp-idf ./install.sh","title":"Linux e macOS"},{"location":"#configurando-as-variaveis-de-ambientes","text":"As ferramentas instaladas ainda n\u00e3o foram adicionadas \u00e0 vari\u00e1vel de ambiente PATH. Para tornar as ferramentas utiliz\u00e1veis na linha de comando, algumas vari\u00e1veis de ambiente devem ser definidas. ESP-IDF fornece alguns scripts que ajudam nesse processo.","title":"Configurando as vari\u00e1veis de ambientes"},{"location":"#windows_2","text":"O ESP-IDF Tools Installer para Windows cria um atalho \u201cESP-IDF Command Prompt\u201d no menu Iniciar. Este atalho abre o Prompt de Comando e configura todas as vari\u00e1veis de ambiente necess\u00e1rias. Voc\u00ea pode abrir este atalho e prosseguir para a pr\u00f3xima etapa. Caso n\u00e3o funcione e voc\u00ea precise configurar manualmente, execute os seguintes comandos: Prompt de Comando : %userprofile%\\esp\\esp-idf\\export.bat Windows PowerShell : .$HOME/esp/esp-idf/export.ps1","title":"Windows"},{"location":"#linux-e-macos_2","text":"No terminal execute: . $HOME/esp/esp-idf/export.sh Voc\u00ea precisa fazer isso toda vez que iniciar o terminal para usar o ESP-IDF.","title":"Linux e macOS"},{"location":"#passo-3-criando-um-novo-projeto","text":"Agora que j\u00e1 temos as ferramentas instaladas, vamos fazer um exemplo para validar o funcionamento das mesmas. Vamos executar o exemplo blink que j\u00e1 vem no IDF.","title":"Passo 3 - Criando um novo projeto"},{"location":"#copiando-um-projeto-exemplo","text":"Vamos copiar o projeto blink para preservarmos o exemplo presente na pasta do IDF:","title":"Copiando um projeto exemplo"},{"location":"#windows_3","text":"cd %userprofile%\\esp xcopy /e /i %IDF_PATH%\\examples\\get-started\\blink blink","title":"Windows"},{"location":"#linux-e-macos_3","text":"cd ~/esp cp -r $IDF_PATH/examples/get-started/blink . Fique a vontade para testar os outros exemplos tamb\u00e9m. O sistema de compila\u00e7\u00e3o ESP-IDF n\u00e3o oferece suporte a espa\u00e7os nos caminhos para o ESP-IDF ou para projetos.","title":"Linux e macOS"},{"location":"#configuracao","text":"Agora vamos configurar o target para qual ser\u00e1 compilado e j\u00e1 fazer uma configura\u00e7\u00e3o no menuconfig. No nosso caso vamos trabalhar com o ESP32-S2:","title":"Configura\u00e7\u00e3o"},{"location":"#windows_4","text":"cd %userprofile%\\esp\\blink idf.py set-target esp32s2 idf.py menuconfig","title":"Windows"},{"location":"#linux-e-macos_4","text":"cd ~/esp/blink idf.py set-target esp32s2 idf.py menuconfig Ser\u00e1 aberto o menuconfig: Acesse a op\u00e7\u00e3o Component config ---> Em seguida ESP System Settings ---> Agora selecione Channel for console output (Default: UART0) ---> E por fim, selecione (X) USB CDC: Salve(S), Enter, enter, Saia do menu(ESC) Essa configura\u00e7\u00e3o permitir\u00e1 que usemos a USB no pr\u00f3ximo upload. Sempre que iniciar um projeto novo fa\u00e7a essas configura\u00e7\u00e3o para que continue usando a USB como interface de programa\u00e7\u00e3o. Para mais detalhes acesse:","title":"Linux e macOS"},{"location":"#compilando-o-projeto-em-modo-dfu","text":"A primeira compila\u00e7\u00e3o n\u00f3s vamos fazer usando o modo DFU, que j\u00e1 vem por padr\u00e3o no ESP32-S2 permitindo o upload atrav\u00e9s da USB: Para crie a imagem DFU: idf.py dfu A primeira compila\u00e7\u00e3o pode demorar um pouco. Da at\u00e9 pra ir pegar um caf\u00e9 ;) Ap\u00f3s a compila\u00e7\u00e3o, conecte a Franzininho WiFi no computador. Antes de fazermos o upload \u00e9 necess\u00e1rio entrar no modo DFU. Para entrar no modo DFU pressione as teclas na seguinte sequencia: pressione e segure a tecla BOOT pressione rapidamente e solte a tecla presente solte a tecla BOOT Dessa forma a placa entrar\u00e1 no modo DFU e poder\u00e1 receber o firmware atrav\u00e9s da USB. Para fazer a grava\u00e7\u00e3o, digite: idf.py dfu-flash Caso tenha permiss\u00e3o de acesso a porta USB, acesse esse link com as instru\u00e7\u00f5es de configura\u00e7\u00f5es Ap\u00f3s alguns segundos a placa estar\u00e1 gravada.","title":"Compilando o projeto em modo DFU"},{"location":"#compilacao-gravacao-e-monitor-em-modo-normal","text":"Agora voc\u00ea poder\u00e1 compilar, gravar e monitorar usando a porta USB. Esse processo \u00e9 id\u00eantico ao que fazemos para desenvolver com o ESP32: Compilar: idf.py build Gravar: idf.py -p PORT [-b BAUD] flash Monitorar: idf.py -p /dev/ttyUSB0 monitor Maravilha, voc\u00ea configurou o ambiente para trabalhar com o ESP-IDF. Caso queira trabalhar com a extens\u00e3o para VSCODE, confira o video:","title":"Compila\u00e7\u00e3o, grava\u00e7\u00e3o e monitor em modo normal"},{"location":"0x01-Hello-world/","text":"Introdu\u00e7\u00e3o O artigo proposto dar\u00e1 in\u00edcio a uma s\u00e9rie de projetos utilizando o framework oficial da Espressif, o IDF. O objetivo deste artigo \u00e9 apresentar um exemplo de projeto que sirva como base para aqueles que est\u00e3o dando seus primeiros passos na fam\u00edlia de microcontroladores ESP32. Como \u00e9 de praxe na programa\u00e7\u00e3o sempre que iniciamos uma nova linguagem ou quando aprendemos sobre um novo processador o primeiro projeto a ser criado \u00e9 o \u201cOl\u00e1 Mundo\u201c, caso contr\u00e1rio teremos um eterno azar, ent\u00e3o o que acha de come\u00e7armos a estudar e apresentar nosso projeto ao Mundo? Ao final desse exemplo voc\u00ea saber\u00e1 como \u00e9 a estrutura b\u00e1sica de um programa no ESP-IDF e estar\u00e1 pronto para os pr\u00f3ximos passos. Recursos Necess\u00e1rios Para esse exemplo voc\u00ea precisar\u00e1 dos seguintes recursos: Placa Franzininho WiFi; Protoboard; LED; Resistor 220R ou 150R; Computador com ESP-IDF instalado e configurado(link) Desenvolvimento Nesse projeto foi utilizado a Franzininho WiFi, uma placa de desenvolvimento baseada no m\u00f3dulo ESP 32-S2 (Wroom ou Wrover), o qual faz parte de uma iniciativa open hardware para ensinar sobre programa\u00e7\u00e3o e eletr\u00f4nica aliando habilidades na soldagem de componentes eletr\u00f4nicos. Como mencionado, vamos fazer o Ol\u00e1 Mundo (Hello, World!), um programa base que tem como objetivo apresentar os recursos prim\u00e1rios do processador em estudo. Nesse primeiro projeto vamos explorar as GPIOs, configuradas como sa\u00edda digital, conectada a um LED externo para ligar e desligar numa frequ\u00eancia de 1 Hertz (1 segundo) e enviar alguns dados de sa\u00edda para serem mostrados no monitor do editor, para aqueles que est\u00e3o migrando do Arduino j\u00e1 est\u00e3o familiarizados com esse exemplo, o famoso \u201cBlink\u201d. Esquem\u00e1tico Antes de come\u00e7armos a escrever as primeiras linhas de c\u00f3digo vamos realizar a montagem do circuito, vale ressaltar que na placa Franzininho WiFi h\u00e1 um LED RGB on board endere\u00e7\u00e1vel, contudo ser\u00e1 utilizado um LED externo, conectado a GPIO 2 ,para o primeiro projeto, vamos nos familiarizarmos com os comandos b\u00e1sicos. Abaixo segue o esquem\u00e1tico proposto: C\u00f3digo O nosso c\u00f3digo possui uma estrutura bem simples e n\u00e3o \u00e9 necess\u00e1rio acrescentar nenhuma biblioteca. Ao criar um novo projeto no IDF j\u00e1 temos arquivos configurados e prontos para programa\u00e7\u00e3o do dispositivo, desta forma digite e comente as linhas do seguinte c\u00f3digo no arquivo main.c : /* Descri\u00e7\u00e3o: Exemplo que mostra Hello World utilizando quatro modalidade de sa\u00edda de dados por meio do terminal e interagindo com um LED externo para indica\u00e7\u00e3o de estado. Autor: Halysson Junior Data : 28/03/21 */ // Arquivos de cabe\u00e7alho #include <stdio.h> #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" #include \"esp_system.h\" #include \"driver/gpio.h\" // Defini\u00e7\u00e3o de pino #define LED 2 // Vari\u00e1vel Global char status[2] = {'L','H'}; // Caracter para indicar estado do LED H- HIGH e L - LOW void app_main(void) // Main { gpio_pad_select_gpio(LED);// Mapeamento do pino LED gpio_set_direction(LED,GPIO_MODE_OUTPUT); // Defini\u00e7\u00e3o printf(\"Exemplo - Hello World \\n\");// Mostra informa\u00e7\u00e3o no terminal //Vari\u00e1veis Local bool i = 0 ; // Varia o estado l\u00f3gico do LED for (;;) {// Loop i= i^1; // Opera\u00e7\u00e3o l\u00f3gica XOR para alternar o estado do LED gpio_set_level(LED,i); // Envia os n\u00edveis l\u00f3gicos 1 ou 0 printf(\"Hello World, i am Franzininho WiFi ----> LED status : %c \\n\", status[i]); vTaskDelay(1000 / portTICK_PERIOD_MS); // Rotina de Delay de 1 segundo fflush(stdout); // Descarrega os buffers de sa\u00edda de dados }// end Loop }// end Main Voc\u00ea encontra o projeto completo na documenta\u00e7\u00e3o da Franzininho: Hello_World Caso ainda n\u00e3o tenha instalado e configurado o IDF no seu computador ou tem d\u00favidas sobre as ferramentas, acesse o tutorial de instala\u00e7\u00e3o Compila\u00e7\u00e3o Ap\u00f3s a codifica\u00e7\u00e3o vamos compilar o c\u00f3digo, mas antes selecione o set target para ESP 32-S2. idf.py set-target esp32s2 Ao final da compila\u00e7\u00e3o o resultado final deve ser semelhante \u00e0 imagem mostrada abaixo, em caso de erros retorne os passos anteriores e revise seu c\u00f3digo. Agora vamos enviar o c\u00f3digo fonte para nossa placa, no editor vamos pressionar o \u00edcone abaixo e aguarde alguns segundos para assim dar in\u00edcio ao programa \u201cOl\u00e1 Mundo\u201d. Para vermos a sa\u00edda de dados do nosso projeto clique no \u00edcone apresentado abaixo. Resultados Com a finaliza\u00e7\u00e3o do projeto o leitor observou que utilizamos uma estrutura\u00e7\u00e3o da linguagem C (main(), printf, fflush()), la\u00e7os de repeti\u00e7\u00e3o (for()) e alguns tipos de vari\u00e1veis primitivas (int e char) para formar nosso c\u00f3digo . Aliados a isso utilizamos labels nativas do IDF para definir os pinos de entrada ou sa\u00edda digital (GPIO_MODE_OUTPUT ). Abaixo segue o resultado final dos dados de sa\u00edda : Abaixo segue o nosso circuito do nosso projeto: Portanto, a partir deste projeto \u00e9 poss\u00edvel aplicar a l\u00f3gica estruturada no c\u00f3digo em diversos outros tipos de sensores, por exemplo : sensor de vibra\u00e7\u00e3o, sensor infravermelho, sensor de som e outros sensores digitais comumente comercializados. Conclus\u00e3o Nesse projeto apresentamos os conceitos b\u00e1sicos para aqueles que desejam dar o pontap\u00e9 inicial nos estudos sobre o IDF, contudo aconselhamos aos leitores a modificar o c\u00f3digo no intuito de revisar a linguagem C e fixar algumas fun\u00e7\u00f5es nativas, os quais ser\u00e3o normalmente utilizadas em outros projetos tamb\u00e9m n\u00e3o limitar-se apenas aos perif\u00e9ricos GPIOs do microcontrolador, pois o ESP32-S2 possui diversos recursos tanto em hardware quanto em software. Desta forma o artigo servir\u00e1 de acervo aos leitores para relembrar conceitos espec\u00edficos e aprimorar os que j\u00e1 possuem. Autor Halysson Junior Data: 13/05/2021","title":"Hello, World!"},{"location":"0x01-Hello-world/#introducao","text":"O artigo proposto dar\u00e1 in\u00edcio a uma s\u00e9rie de projetos utilizando o framework oficial da Espressif, o IDF. O objetivo deste artigo \u00e9 apresentar um exemplo de projeto que sirva como base para aqueles que est\u00e3o dando seus primeiros passos na fam\u00edlia de microcontroladores ESP32. Como \u00e9 de praxe na programa\u00e7\u00e3o sempre que iniciamos uma nova linguagem ou quando aprendemos sobre um novo processador o primeiro projeto a ser criado \u00e9 o \u201cOl\u00e1 Mundo\u201c, caso contr\u00e1rio teremos um eterno azar, ent\u00e3o o que acha de come\u00e7armos a estudar e apresentar nosso projeto ao Mundo? Ao final desse exemplo voc\u00ea saber\u00e1 como \u00e9 a estrutura b\u00e1sica de um programa no ESP-IDF e estar\u00e1 pronto para os pr\u00f3ximos passos.","title":"Introdu\u00e7\u00e3o"},{"location":"0x01-Hello-world/#recursos-necessarios","text":"Para esse exemplo voc\u00ea precisar\u00e1 dos seguintes recursos: Placa Franzininho WiFi; Protoboard; LED; Resistor 220R ou 150R; Computador com ESP-IDF instalado e configurado(link)","title":"Recursos Necess\u00e1rios"},{"location":"0x01-Hello-world/#desenvolvimento","text":"Nesse projeto foi utilizado a Franzininho WiFi, uma placa de desenvolvimento baseada no m\u00f3dulo ESP 32-S2 (Wroom ou Wrover), o qual faz parte de uma iniciativa open hardware para ensinar sobre programa\u00e7\u00e3o e eletr\u00f4nica aliando habilidades na soldagem de componentes eletr\u00f4nicos. Como mencionado, vamos fazer o Ol\u00e1 Mundo (Hello, World!), um programa base que tem como objetivo apresentar os recursos prim\u00e1rios do processador em estudo. Nesse primeiro projeto vamos explorar as GPIOs, configuradas como sa\u00edda digital, conectada a um LED externo para ligar e desligar numa frequ\u00eancia de 1 Hertz (1 segundo) e enviar alguns dados de sa\u00edda para serem mostrados no monitor do editor, para aqueles que est\u00e3o migrando do Arduino j\u00e1 est\u00e3o familiarizados com esse exemplo, o famoso \u201cBlink\u201d.","title":"Desenvolvimento"},{"location":"0x01-Hello-world/#esquematico","text":"Antes de come\u00e7armos a escrever as primeiras linhas de c\u00f3digo vamos realizar a montagem do circuito, vale ressaltar que na placa Franzininho WiFi h\u00e1 um LED RGB on board endere\u00e7\u00e1vel, contudo ser\u00e1 utilizado um LED externo, conectado a GPIO 2 ,para o primeiro projeto, vamos nos familiarizarmos com os comandos b\u00e1sicos. Abaixo segue o esquem\u00e1tico proposto:","title":"Esquem\u00e1tico"},{"location":"0x01-Hello-world/#codigo","text":"O nosso c\u00f3digo possui uma estrutura bem simples e n\u00e3o \u00e9 necess\u00e1rio acrescentar nenhuma biblioteca. Ao criar um novo projeto no IDF j\u00e1 temos arquivos configurados e prontos para programa\u00e7\u00e3o do dispositivo, desta forma digite e comente as linhas do seguinte c\u00f3digo no arquivo main.c : /* Descri\u00e7\u00e3o: Exemplo que mostra Hello World utilizando quatro modalidade de sa\u00edda de dados por meio do terminal e interagindo com um LED externo para indica\u00e7\u00e3o de estado. Autor: Halysson Junior Data : 28/03/21 */ // Arquivos de cabe\u00e7alho #include <stdio.h> #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" #include \"esp_system.h\" #include \"driver/gpio.h\" // Defini\u00e7\u00e3o de pino #define LED 2 // Vari\u00e1vel Global char status[2] = {'L','H'}; // Caracter para indicar estado do LED H- HIGH e L - LOW void app_main(void) // Main { gpio_pad_select_gpio(LED);// Mapeamento do pino LED gpio_set_direction(LED,GPIO_MODE_OUTPUT); // Defini\u00e7\u00e3o printf(\"Exemplo - Hello World \\n\");// Mostra informa\u00e7\u00e3o no terminal //Vari\u00e1veis Local bool i = 0 ; // Varia o estado l\u00f3gico do LED for (;;) {// Loop i= i^1; // Opera\u00e7\u00e3o l\u00f3gica XOR para alternar o estado do LED gpio_set_level(LED,i); // Envia os n\u00edveis l\u00f3gicos 1 ou 0 printf(\"Hello World, i am Franzininho WiFi ----> LED status : %c \\n\", status[i]); vTaskDelay(1000 / portTICK_PERIOD_MS); // Rotina de Delay de 1 segundo fflush(stdout); // Descarrega os buffers de sa\u00edda de dados }// end Loop }// end Main Voc\u00ea encontra o projeto completo na documenta\u00e7\u00e3o da Franzininho: Hello_World Caso ainda n\u00e3o tenha instalado e configurado o IDF no seu computador ou tem d\u00favidas sobre as ferramentas, acesse o tutorial de instala\u00e7\u00e3o","title":"C\u00f3digo"},{"location":"0x01-Hello-world/#compilacao","text":"Ap\u00f3s a codifica\u00e7\u00e3o vamos compilar o c\u00f3digo, mas antes selecione o set target para ESP 32-S2. idf.py set-target esp32s2 Ao final da compila\u00e7\u00e3o o resultado final deve ser semelhante \u00e0 imagem mostrada abaixo, em caso de erros retorne os passos anteriores e revise seu c\u00f3digo. Agora vamos enviar o c\u00f3digo fonte para nossa placa, no editor vamos pressionar o \u00edcone abaixo e aguarde alguns segundos para assim dar in\u00edcio ao programa \u201cOl\u00e1 Mundo\u201d. Para vermos a sa\u00edda de dados do nosso projeto clique no \u00edcone apresentado abaixo.","title":"Compila\u00e7\u00e3o"},{"location":"0x01-Hello-world/#resultados","text":"Com a finaliza\u00e7\u00e3o do projeto o leitor observou que utilizamos uma estrutura\u00e7\u00e3o da linguagem C (main(), printf, fflush()), la\u00e7os de repeti\u00e7\u00e3o (for()) e alguns tipos de vari\u00e1veis primitivas (int e char) para formar nosso c\u00f3digo . Aliados a isso utilizamos labels nativas do IDF para definir os pinos de entrada ou sa\u00edda digital (GPIO_MODE_OUTPUT ). Abaixo segue o resultado final dos dados de sa\u00edda :","title":"Resultados"},{"location":"0x01-Hello-world/#abaixo-segue-o-nosso-circuito-do-nosso-projeto","text":"Portanto, a partir deste projeto \u00e9 poss\u00edvel aplicar a l\u00f3gica estruturada no c\u00f3digo em diversos outros tipos de sensores, por exemplo : sensor de vibra\u00e7\u00e3o, sensor infravermelho, sensor de som e outros sensores digitais comumente comercializados.","title":"Abaixo segue o nosso circuito do nosso projeto:"},{"location":"0x01-Hello-world/#conclusao","text":"Nesse projeto apresentamos os conceitos b\u00e1sicos para aqueles que desejam dar o pontap\u00e9 inicial nos estudos sobre o IDF, contudo aconselhamos aos leitores a modificar o c\u00f3digo no intuito de revisar a linguagem C e fixar algumas fun\u00e7\u00f5es nativas, os quais ser\u00e3o normalmente utilizadas em outros projetos tamb\u00e9m n\u00e3o limitar-se apenas aos perif\u00e9ricos GPIOs do microcontrolador, pois o ESP32-S2 possui diversos recursos tanto em hardware quanto em software. Desta forma o artigo servir\u00e1 de acervo aos leitores para relembrar conceitos espec\u00edficos e aprimorar os que j\u00e1 possuem. Autor Halysson Junior Data: 13/05/2021","title":"Conclus\u00e3o"},{"location":"0x02-entrada-digital/","text":"Seguindo nas aplica\u00e7\u00f5es com o ESP-IDF naa placa Franzininho WiFi vamos dar continuidade aos trabalhos com o perif\u00e9rico de Entrada/Sa\u00edda de Prop\u00f3sito Geral ou do ingl\u00eas General Purpose Input/Output (GPIO) . O objetivo deste texto \u00e9 apresentar um exemplo de projeto para configurar os pinos como entrada digital. Ao final, estaremos preparados para manipular tanto as sa\u00eddas digitais, vista anteriormente, quanto \u00e0s entradas de digitais. Recursos Necess\u00e1rios Os materiais necess\u00e1rios para realizar esse exemplo s\u00e3o: Placa Franzininho WiFi; Protoboard; Bot\u00e3o ou chave t\u00e1ctil; LED; Resistor de 220 ou 330 Ohm; Cabos Jumpers; Computador com ESP-IDF instalado e configurado. Recursos Necess\u00e1rios Os materiais necess\u00e1rios para realizar esse exemplo s\u00e3o: Placa Franzininho WiFi; Protoboard; Bot\u00e3o ou chave t\u00e1ctil; LED; Resistor de 220 ou 330 Ohm; Cabos Jumpers; Computador com ESP-IDF instalado e configurado. Desenvolvimento Nesse artigo vamos apresentar um exemplo de projeto utilizando as duas fun\u00e7\u00f5es do perif\u00e9rico GPIO: entrada digital e sa\u00edda digital. Na entrada digital vamos realizar a leitura do bot\u00e3o t\u00e1ctil e armazenar seu estado em uma vari\u00e1vel que ir\u00e1 interagir com o monitor e um LED externo, atuando como uma sa\u00edda digital que ir\u00e1 nos indicar o estado atual do bot\u00e3o. O programa desenvolvido possibilita utilizar duas topologias de circuito : pull up ou pull down , para mais informa\u00e7\u00f5es sobre essas topologias acesse os links referente a cada circuito. Nesse exemplo de projeto iremos utilizar a topologia com o pull up interno do processador, desta forma deve-se observar os coment\u00e1rios ao longo do c\u00f3digo a fim de habilitar ou desabilitar as topologias de circuito. Na placa Franzininho WiFI temos 38 pinos program\u00e1veis com o perif\u00e9rico GPIO, encorajamos aos leitores que alterem o c\u00f3digo da forma como achar necess\u00e1rio e praticar a codifica\u00e7\u00e3o do programa a fim de consolidar o conhecimento adquirido. Esquem\u00e1tico Para darmos in\u00edcio ao projeto \u00e9 importante realizar a montagem do circuito em protoboard observando com cuidado as conex\u00f5es, iremos conectar um dos terminais do resistor no GPIO 2 e outro no LED externo por fim ligamos a GPIO 15 no bot\u00e3o t\u00e1ctil. Abaixo segue o esquem\u00e1tico proposto: C\u00f3digo O programa desenvolvido possui uma estrutura bem simples e n\u00e3o \u00e9 necess\u00e1rio acrescentar nenhuma biblioteca, apenas a manuten\u00e7\u00e3o dos arquivos de cabe\u00e7alho j\u00e1 presentes no projeto. Ao criar um novo projeto no IDF automaticamente j\u00e1 temos arquivos configurados e prontos para programa\u00e7\u00e3o do dispositivo, desta forma digite e comente as linhas do seguinte c\u00f3digo no arquivo main.c : /* Autor : Halysson Junior Data: 31/03/21 Descri\u00e7\u00e3o: Neste exemplo utilizou-se um bot\u00e3o t\u00e1ctil (entrada digital) para acionar um LED (sa\u00edda digital) e mostra seu estado no terminal. */ // Inclus\u00e3o arquivos de cabe\u00e7alho #include <stdio.h> #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" #include \"driver/gpio.h\" #include \"sdkconfig.h\" // Defini\u00e7\u00f5es de Pinos #define BTN 15 #define LED 2 // Defini\u00e7\u00e3o de habilita\u00e7\u00e3o (PULLUP / PULLDOWN) #define PULLUP // #define PULLDOWN (Para habilitar pulldown descomente aqui e comente -> \" #define PULLUP \") // Defini\u00e7\u00f5es de estado l\u00f3gico (caso altere para pulldown, deve-se inverter os estado l\u00f3gicos) #define ON 1 #define OFF 0 void app_main(void){ // Main gpio_pad_select_gpio(LED); gpio_set_direction(LED,GPIO_MODE_OUTPUT);// onfigura LED como sa\u00edda digital gpio_pad_select_gpio(BTN); gpio_set_direction(BTN,GPIO_MODE_INPUT); // Configura LED como sa\u00edda digital #ifdef PULLDOWN // Habilita pulldown gpio_pulldown_en(BTN); gpio_pullup_dis(BTN); #endif #ifdef PULLUP // Habilita pullup gpio_pullup_en(BTN); gpio_pulldown_dis(BTN); #endif // V\u00e1riavel Local bool last_state_btn = 0; // Armazena o \u00faltimo estado do bot\u00e3o while (1) { // Loop // V\u00e1riavel Local bool state_btn = gpio_get_level(BTN); // Leitura do bot\u00e3o if(!state_btn && !last_state_btn) { gpio_set_level(LED,ON); // Se bot\u00e3o for zero ent\u00e3o ... liga LED printf(\"LED LIGADO\"); // Mostra informa\u00e7\u00e3o no monitor \"LED LIGADO\" last_state_btn = true; // Bot\u00e3o pressionado } else if(state_btn && last_state_btn){ gpio_set_level(LED,OFF); // Sen\u00e3o... desliga LED printf (\"LED DESLIGADO\"); // Mostra informa\u00e7\u00e3o no monitor \"LED DESLIGADO\" last_state_btn = false; // Bot\u00e3o solto } vTaskDelay(1/ portTICK_PERIOD_MS); // Rotina de Delay de 1 segundo fflush(stdout); // Descarrega os buffers de sa\u00edda de dados }// endLoop }// endMain Voc\u00ea encontra o projeto completo na documenta\u00e7\u00e3o da Franzininho: Button Caso ainda n\u00e3o tenha instalado e configurado o IDF no seu computador ou tenha d\u00favidas sobre as ferramentas, acesse o tutorial de instala\u00e7\u00e3o ( Clique Aqui ). Compila\u00e7\u00e3o Ap\u00f3s a codifica\u00e7\u00e3o vamos compilar o c\u00f3digo, mas antes selecione o set-target para ESP 32-S2: idf.py set-target esp32s2 Ao final da compila\u00e7\u00e3o o resultado final deve ser semelhante \u00e0 imagem mostrada abaixo, em caso de erros retorne os passos anteriores e revise seu c\u00f3digo. Ap\u00f3s a etapa de compila\u00e7\u00e3o vamos enviar o c\u00f3digo fonte para nossa placa, no editor pressione o \u00edcone abaixo e aguarde alguns segundos para assim dar in\u00edcio ao programa \u201cButton\u201d(seta preta) e para vermos a sa\u00edda de dados do nosso projeto clique no \u00edcone no formato de monitor (seta vermelha): Resultados Finalizando o exemplo de projeto o leitor deve ter observado que no programa Button, foram utilizadas as estruturas de condi\u00e7\u00e3o IF / ELSE IF para interagir com o estado atual do bot\u00e3o, adicionou-se \u00e0s uma nova label nativa para indicar as entradas digitais (GPIO_MODE_INPUT) e as fun\u00e7\u00f5es para indicar topologia do circuito ( gpio_pullup_en()/gpio pulldown_dis()) utilizado e verificar a leitura digital no pino definido no cabe\u00e7alho do c\u00f3digo. Abaixo segue o resultado final dos dados de sa\u00edda no monitor: Abaixo segue o nosso circuito do nosso projeto: Conclus\u00e3o Nesse projeto conclu\u00edmos o estudo do perif\u00e9rico base para iniciar no mundo dos microcontroladores, pois a partir desse conhecimento adquirido podemos reciclar para as outras fam\u00edlias do ESP32, como tamb\u00e9m em outros chips baseados na linguagem C para estruturar seu programa. Como mencionado na se\u00e7\u00e3o de Desenvolvimento, este segundo artigo deseja consolidar o conhecimento nesse perif\u00e9rico (GPIO), por tanto deixo o desafio de criar um contador de pulsos de 0 at\u00e9 10 e reiniciado sempre quando forma maior que 10, ao final de cada contagem deve-se acionar um LED e mostrar quantas contagens j\u00e1 foram feitas. Desejo sorte \u00e0queles que ir\u00e3o realizar o desafio e bons estudos, que a for\u00e7a esteja com todos n\u00f3s. Autor Halysson Junior Data: 01/06/2021","title":"Entrada digital"},{"location":"0x02-entrada-digital/#recursos-necessarios","text":"Os materiais necess\u00e1rios para realizar esse exemplo s\u00e3o: Placa Franzininho WiFi; Protoboard; Bot\u00e3o ou chave t\u00e1ctil; LED; Resistor de 220 ou 330 Ohm; Cabos Jumpers; Computador com ESP-IDF instalado e configurado.","title":"Recursos Necess\u00e1rios"},{"location":"0x02-entrada-digital/#recursos-necessarios_1","text":"Os materiais necess\u00e1rios para realizar esse exemplo s\u00e3o: Placa Franzininho WiFi; Protoboard; Bot\u00e3o ou chave t\u00e1ctil; LED; Resistor de 220 ou 330 Ohm; Cabos Jumpers; Computador com ESP-IDF instalado e configurado.","title":"Recursos Necess\u00e1rios"},{"location":"0x02-entrada-digital/#desenvolvimento","text":"Nesse artigo vamos apresentar um exemplo de projeto utilizando as duas fun\u00e7\u00f5es do perif\u00e9rico GPIO: entrada digital e sa\u00edda digital. Na entrada digital vamos realizar a leitura do bot\u00e3o t\u00e1ctil e armazenar seu estado em uma vari\u00e1vel que ir\u00e1 interagir com o monitor e um LED externo, atuando como uma sa\u00edda digital que ir\u00e1 nos indicar o estado atual do bot\u00e3o. O programa desenvolvido possibilita utilizar duas topologias de circuito : pull up ou pull down , para mais informa\u00e7\u00f5es sobre essas topologias acesse os links referente a cada circuito. Nesse exemplo de projeto iremos utilizar a topologia com o pull up interno do processador, desta forma deve-se observar os coment\u00e1rios ao longo do c\u00f3digo a fim de habilitar ou desabilitar as topologias de circuito. Na placa Franzininho WiFI temos 38 pinos program\u00e1veis com o perif\u00e9rico GPIO, encorajamos aos leitores que alterem o c\u00f3digo da forma como achar necess\u00e1rio e praticar a codifica\u00e7\u00e3o do programa a fim de consolidar o conhecimento adquirido.","title":"Desenvolvimento"},{"location":"0x02-entrada-digital/#esquematico","text":"Para darmos in\u00edcio ao projeto \u00e9 importante realizar a montagem do circuito em protoboard observando com cuidado as conex\u00f5es, iremos conectar um dos terminais do resistor no GPIO 2 e outro no LED externo por fim ligamos a GPIO 15 no bot\u00e3o t\u00e1ctil. Abaixo segue o esquem\u00e1tico proposto:","title":"Esquem\u00e1tico"},{"location":"0x02-entrada-digital/#codigo","text":"O programa desenvolvido possui uma estrutura bem simples e n\u00e3o \u00e9 necess\u00e1rio acrescentar nenhuma biblioteca, apenas a manuten\u00e7\u00e3o dos arquivos de cabe\u00e7alho j\u00e1 presentes no projeto. Ao criar um novo projeto no IDF automaticamente j\u00e1 temos arquivos configurados e prontos para programa\u00e7\u00e3o do dispositivo, desta forma digite e comente as linhas do seguinte c\u00f3digo no arquivo main.c : /* Autor : Halysson Junior Data: 31/03/21 Descri\u00e7\u00e3o: Neste exemplo utilizou-se um bot\u00e3o t\u00e1ctil (entrada digital) para acionar um LED (sa\u00edda digital) e mostra seu estado no terminal. */ // Inclus\u00e3o arquivos de cabe\u00e7alho #include <stdio.h> #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" #include \"driver/gpio.h\" #include \"sdkconfig.h\" // Defini\u00e7\u00f5es de Pinos #define BTN 15 #define LED 2 // Defini\u00e7\u00e3o de habilita\u00e7\u00e3o (PULLUP / PULLDOWN) #define PULLUP // #define PULLDOWN (Para habilitar pulldown descomente aqui e comente -> \" #define PULLUP \") // Defini\u00e7\u00f5es de estado l\u00f3gico (caso altere para pulldown, deve-se inverter os estado l\u00f3gicos) #define ON 1 #define OFF 0 void app_main(void){ // Main gpio_pad_select_gpio(LED); gpio_set_direction(LED,GPIO_MODE_OUTPUT);// onfigura LED como sa\u00edda digital gpio_pad_select_gpio(BTN); gpio_set_direction(BTN,GPIO_MODE_INPUT); // Configura LED como sa\u00edda digital #ifdef PULLDOWN // Habilita pulldown gpio_pulldown_en(BTN); gpio_pullup_dis(BTN); #endif #ifdef PULLUP // Habilita pullup gpio_pullup_en(BTN); gpio_pulldown_dis(BTN); #endif // V\u00e1riavel Local bool last_state_btn = 0; // Armazena o \u00faltimo estado do bot\u00e3o while (1) { // Loop // V\u00e1riavel Local bool state_btn = gpio_get_level(BTN); // Leitura do bot\u00e3o if(!state_btn && !last_state_btn) { gpio_set_level(LED,ON); // Se bot\u00e3o for zero ent\u00e3o ... liga LED printf(\"LED LIGADO\"); // Mostra informa\u00e7\u00e3o no monitor \"LED LIGADO\" last_state_btn = true; // Bot\u00e3o pressionado } else if(state_btn && last_state_btn){ gpio_set_level(LED,OFF); // Sen\u00e3o... desliga LED printf (\"LED DESLIGADO\"); // Mostra informa\u00e7\u00e3o no monitor \"LED DESLIGADO\" last_state_btn = false; // Bot\u00e3o solto } vTaskDelay(1/ portTICK_PERIOD_MS); // Rotina de Delay de 1 segundo fflush(stdout); // Descarrega os buffers de sa\u00edda de dados }// endLoop }// endMain Voc\u00ea encontra o projeto completo na documenta\u00e7\u00e3o da Franzininho: Button Caso ainda n\u00e3o tenha instalado e configurado o IDF no seu computador ou tenha d\u00favidas sobre as ferramentas, acesse o tutorial de instala\u00e7\u00e3o ( Clique Aqui ).","title":"C\u00f3digo"},{"location":"0x02-entrada-digital/#compilacao","text":"Ap\u00f3s a codifica\u00e7\u00e3o vamos compilar o c\u00f3digo, mas antes selecione o set-target para ESP 32-S2: idf.py set-target esp32s2 Ao final da compila\u00e7\u00e3o o resultado final deve ser semelhante \u00e0 imagem mostrada abaixo, em caso de erros retorne os passos anteriores e revise seu c\u00f3digo. Ap\u00f3s a etapa de compila\u00e7\u00e3o vamos enviar o c\u00f3digo fonte para nossa placa, no editor pressione o \u00edcone abaixo e aguarde alguns segundos para assim dar in\u00edcio ao programa \u201cButton\u201d(seta preta) e para vermos a sa\u00edda de dados do nosso projeto clique no \u00edcone no formato de monitor (seta vermelha):","title":"Compila\u00e7\u00e3o"},{"location":"0x02-entrada-digital/#resultados","text":"Finalizando o exemplo de projeto o leitor deve ter observado que no programa Button, foram utilizadas as estruturas de condi\u00e7\u00e3o IF / ELSE IF para interagir com o estado atual do bot\u00e3o, adicionou-se \u00e0s uma nova label nativa para indicar as entradas digitais (GPIO_MODE_INPUT) e as fun\u00e7\u00f5es para indicar topologia do circuito ( gpio_pullup_en()/gpio pulldown_dis()) utilizado e verificar a leitura digital no pino definido no cabe\u00e7alho do c\u00f3digo. Abaixo segue o resultado final dos dados de sa\u00edda no monitor: Abaixo segue o nosso circuito do nosso projeto:","title":"Resultados"},{"location":"0x02-entrada-digital/#conclusao","text":"Nesse projeto conclu\u00edmos o estudo do perif\u00e9rico base para iniciar no mundo dos microcontroladores, pois a partir desse conhecimento adquirido podemos reciclar para as outras fam\u00edlias do ESP32, como tamb\u00e9m em outros chips baseados na linguagem C para estruturar seu programa. Como mencionado na se\u00e7\u00e3o de Desenvolvimento, este segundo artigo deseja consolidar o conhecimento nesse perif\u00e9rico (GPIO), por tanto deixo o desafio de criar um contador de pulsos de 0 at\u00e9 10 e reiniciado sempre quando forma maior que 10, ao final de cada contagem deve-se acionar um LED e mostrar quantas contagens j\u00e1 foram feitas. Desejo sorte \u00e0queles que ir\u00e3o realizar o desafio e bons estudos, que a for\u00e7a esteja com todos n\u00f3s. Autor Halysson Junior Data: 01/06/2021","title":"Conclus\u00e3o"},{"location":"0x03-entrada-analogica/","text":"Introdu\u00e7\u00e3o Nesse exemplo vamos entender como usar o Conversor Anal\u00f3gico-Digital (Analog to Digital Converter(ADC)) na Franzininho WiFi. O objetivo deste exemplo \u00e9 apresentar projeto simples para configurar o ADC, ler o valor de uma entrada anal\u00f3gica controlada por um potenci\u00f4metro e imprimir o valor da convers\u00e3o atrav\u00e9s da comunica\u00e7\u00e3o serial. Ao final, estaremos preparados para fazer leitura anal\u00f3gica simples como tamb\u00e9m para utiliza\u00e7\u00e3o de sensores mais complexos. Recursos Placa Franzininho WIFI Potenci\u00f4metro Protoboard Jumpers Computador com ESP-IDF instalado e configurado. Desenvolvimento Um potenci\u00f4metro \u00e9 um dispositivo anal\u00f3gico rotativo operado mecanicamente por meio de Um potenci\u00f4metro \u00e9 um dispositivo anal\u00f3gico rotativo operado mecanicamente por meio de 3 terminais, ele fornece uma quantidade vari\u00e1vel de resist\u00eancia quando seu eixo \u00e9 girado. Quando uma tens\u00e3o \u00e9 aplicada nos terminais do potenci\u00f4metro, que est\u00e1 conectado a uma entrada anal\u00f3gica, conseguimos medir uma resist\u00eancia produzida pelo potenci\u00f4metro como um valor anal\u00f3gico. O Conversor Analogico-Digital \u00e9 um dispositivo que converte um sinal anal\u00f3gico num sinal digital. Logo, este exemplo vem com o intuito de monitorar o estado do potenci\u00f4metro a partir de uma comunica\u00e7\u00e3o serial, assim podemos ter base para trabalharmos futuramente com sensores anal\u00f3gicos. Conecte os tr\u00eas fios do potenci\u00f4metro \u00e0 sua placa. O primeiro fio vai de um dos pinos externos do potenci\u00f4metro para o GND. J\u00e1 o segundo vai do outro pino externo do potenci\u00f4metro para 3,3 Volts. E por \u00faltimo, o terceiro vai do pino do meio do potenci\u00f4metro ao pino anal\u00f3gico GPIO1. Quando se gira o potenci\u00f4metro, altera-se a resist\u00eancia, impactando diretamente no pino central do potenci\u00f4metro, portanto, muda-se a tens\u00e3o. Quando o eixo \u00e9 girado no sentido direito a tens\u00e3o se aproxima de 3,3V, ao contr\u00e1rio se aproxima de 0. Essa tens\u00e3o que voc\u00ea est\u00e1 lendo na entrada anal\u00f3gica. A Franzininho WIFI possui 20 entradas de ADC, sendo que o ADC1 possui 10 canais configurados do GPIO1 ao GPIO10, j\u00e1 o ADC2 possui 10 canais configurados do GPIO11 ao GPIO20. O conversor anal\u00f3gico-digital da ESP32-S2 que iremos utilizar possui 12bits de resolu\u00e7\u00e3o, portanto, ele l\u00ea a tens\u00e3o e a converte em um n\u00famero entre 0 a 4095. A fun\u00e7\u00e3o adc1_get_raw() ir\u00e1 fazer a captura da quantidade de tens\u00e3o aplicada ao pino do canal configurado. Esquem\u00e1tico Em uma protoboard, conecte os tr\u00eas fios do potenci\u00f4metro na Franzininho WIFI. O primeiro vai de um dos pinos externos do potenci\u00f4metro para o GND. O segundo vai do outro pino externo do potenci\u00f4metro para 3,3 volts. O terceiro vai do pino do meio do potenci\u00f4metro ao pino anal\u00f3gico GPIO1. C\u00f3digo /* Autor : Kayann Soares Utiliza\u00e7\u00e3o simples da Leitura de Dados Analogicos. */ // Bibliotecas Necessarias #include <stdio.h> #include \"sdkconfig.h\" #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" #include \"esp_system.h\" #include \"esp_spi_flash.h\" #include <driver/adc.h> // Main void app_main(){ // Configurando a resolu\u00e7\u00e3o do ADC para 12bits adc1_config_width(ADC_WIDTH_BIT_12); // Configurando o Channel do ADC para o Channel 0 adc1_config_channel_atten(ADC1_CHANNEL_0,ADC_ATTEN_DB_11); while(1){ // Fun\u00e7\u00e3o que de leitura do valor analogico, passando o ADC1 que \u00e9 o do GPIO1 int sensorValue = adc1_get_raw(ADC1_CHANNEL_0); // Imprimindo valores lidos printf(\"%d\\n\", sensorValue); // Rotina de Delay de 1 segundo vTaskDelay(1000 / portTICK_PERIOD_MS); // Descarrega os buffers de sa\u00edda de dados fflush(stdout); } } Compila\u00e7\u00e3o Ap\u00f3s a codifica\u00e7\u00e3o vamos compilar o c\u00f3digo, mas antes selecione o set-target para ESP 32-S2: idf.py set-target esp32s2 Ap\u00f3s a compila\u00e7\u00e3o vamos enviar o c\u00f3digo fonte para nossa placa, no editor pressione o \u00edcone de raio para dar o FLASH e aguarde alguns segundos para assim dar in\u00edcio ao programa Para vermos a sa\u00edda de dados do nosso projeto clique no \u00edcone no formato de monitor: Resultados Valores mostrados no terminal quando o potenci\u00f4metro \u00e9 rotacionado. Conclus\u00e3o Conclu\u00edmos o estudo do perif\u00e9rico base para iniciar no desenvolvimento com microcontroladores da Espressif usando o Framework IDF, a partir desse artigo podemos replicar para as demais fam\u00edlias do ESP32, estes conceitos podem ser levados tamb\u00e9m para trabalharmos com outros microcontroladores que utilizem C e uma programa\u00e7\u00e3o mais abstrata. Este artigo visa no estudo do perif\u00e9rico ADC, ao final deste projeto \u00e9 poss\u00edvel aprender a utilizar o ADC da Franzininho WiFi para leitura de dados anal\u00f3gicos e lhe dar\u00e1 o desafio de aplicar esse aprendizado na leitura de sensores anal\u00f3gicos para voc\u00ea aplicar em seus projetos utilizando o ESP-IDF. Bons estudos. Autor Kayann Soares Data: 01/06/2021","title":"Entrada Anal\u00f3gica"},{"location":"0x03-entrada-analogica/#introducao","text":"Nesse exemplo vamos entender como usar o Conversor Anal\u00f3gico-Digital (Analog to Digital Converter(ADC)) na Franzininho WiFi. O objetivo deste exemplo \u00e9 apresentar projeto simples para configurar o ADC, ler o valor de uma entrada anal\u00f3gica controlada por um potenci\u00f4metro e imprimir o valor da convers\u00e3o atrav\u00e9s da comunica\u00e7\u00e3o serial. Ao final, estaremos preparados para fazer leitura anal\u00f3gica simples como tamb\u00e9m para utiliza\u00e7\u00e3o de sensores mais complexos.","title":"Introdu\u00e7\u00e3o"},{"location":"0x03-entrada-analogica/#recursos","text":"Placa Franzininho WIFI Potenci\u00f4metro Protoboard Jumpers Computador com ESP-IDF instalado e configurado.","title":"Recursos"},{"location":"0x03-entrada-analogica/#desenvolvimento","text":"Um potenci\u00f4metro \u00e9 um dispositivo anal\u00f3gico rotativo operado mecanicamente por meio de Um potenci\u00f4metro \u00e9 um dispositivo anal\u00f3gico rotativo operado mecanicamente por meio de 3 terminais, ele fornece uma quantidade vari\u00e1vel de resist\u00eancia quando seu eixo \u00e9 girado. Quando uma tens\u00e3o \u00e9 aplicada nos terminais do potenci\u00f4metro, que est\u00e1 conectado a uma entrada anal\u00f3gica, conseguimos medir uma resist\u00eancia produzida pelo potenci\u00f4metro como um valor anal\u00f3gico. O Conversor Analogico-Digital \u00e9 um dispositivo que converte um sinal anal\u00f3gico num sinal digital. Logo, este exemplo vem com o intuito de monitorar o estado do potenci\u00f4metro a partir de uma comunica\u00e7\u00e3o serial, assim podemos ter base para trabalharmos futuramente com sensores anal\u00f3gicos. Conecte os tr\u00eas fios do potenci\u00f4metro \u00e0 sua placa. O primeiro fio vai de um dos pinos externos do potenci\u00f4metro para o GND. J\u00e1 o segundo vai do outro pino externo do potenci\u00f4metro para 3,3 Volts. E por \u00faltimo, o terceiro vai do pino do meio do potenci\u00f4metro ao pino anal\u00f3gico GPIO1. Quando se gira o potenci\u00f4metro, altera-se a resist\u00eancia, impactando diretamente no pino central do potenci\u00f4metro, portanto, muda-se a tens\u00e3o. Quando o eixo \u00e9 girado no sentido direito a tens\u00e3o se aproxima de 3,3V, ao contr\u00e1rio se aproxima de 0. Essa tens\u00e3o que voc\u00ea est\u00e1 lendo na entrada anal\u00f3gica. A Franzininho WIFI possui 20 entradas de ADC, sendo que o ADC1 possui 10 canais configurados do GPIO1 ao GPIO10, j\u00e1 o ADC2 possui 10 canais configurados do GPIO11 ao GPIO20. O conversor anal\u00f3gico-digital da ESP32-S2 que iremos utilizar possui 12bits de resolu\u00e7\u00e3o, portanto, ele l\u00ea a tens\u00e3o e a converte em um n\u00famero entre 0 a 4095. A fun\u00e7\u00e3o adc1_get_raw() ir\u00e1 fazer a captura da quantidade de tens\u00e3o aplicada ao pino do canal configurado.","title":"Desenvolvimento"},{"location":"0x03-entrada-analogica/#esquematico","text":"Em uma protoboard, conecte os tr\u00eas fios do potenci\u00f4metro na Franzininho WIFI. O primeiro vai de um dos pinos externos do potenci\u00f4metro para o GND. O segundo vai do outro pino externo do potenci\u00f4metro para 3,3 volts. O terceiro vai do pino do meio do potenci\u00f4metro ao pino anal\u00f3gico GPIO1.","title":"Esquem\u00e1tico"},{"location":"0x03-entrada-analogica/#codigo","text":"/* Autor : Kayann Soares Utiliza\u00e7\u00e3o simples da Leitura de Dados Analogicos. */ // Bibliotecas Necessarias #include <stdio.h> #include \"sdkconfig.h\" #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" #include \"esp_system.h\" #include \"esp_spi_flash.h\" #include <driver/adc.h> // Main void app_main(){ // Configurando a resolu\u00e7\u00e3o do ADC para 12bits adc1_config_width(ADC_WIDTH_BIT_12); // Configurando o Channel do ADC para o Channel 0 adc1_config_channel_atten(ADC1_CHANNEL_0,ADC_ATTEN_DB_11); while(1){ // Fun\u00e7\u00e3o que de leitura do valor analogico, passando o ADC1 que \u00e9 o do GPIO1 int sensorValue = adc1_get_raw(ADC1_CHANNEL_0); // Imprimindo valores lidos printf(\"%d\\n\", sensorValue); // Rotina de Delay de 1 segundo vTaskDelay(1000 / portTICK_PERIOD_MS); // Descarrega os buffers de sa\u00edda de dados fflush(stdout); } }","title":"C\u00f3digo"},{"location":"0x03-entrada-analogica/#compilacao","text":"Ap\u00f3s a codifica\u00e7\u00e3o vamos compilar o c\u00f3digo, mas antes selecione o set-target para ESP 32-S2: idf.py set-target esp32s2 Ap\u00f3s a compila\u00e7\u00e3o vamos enviar o c\u00f3digo fonte para nossa placa, no editor pressione o \u00edcone de raio para dar o FLASH e aguarde alguns segundos para assim dar in\u00edcio ao programa Para vermos a sa\u00edda de dados do nosso projeto clique no \u00edcone no formato de monitor:","title":"Compila\u00e7\u00e3o"},{"location":"0x03-entrada-analogica/#resultados","text":"Valores mostrados no terminal quando o potenci\u00f4metro \u00e9 rotacionado.","title":"Resultados"},{"location":"0x03-entrada-analogica/#conclusao","text":"Conclu\u00edmos o estudo do perif\u00e9rico base para iniciar no desenvolvimento com microcontroladores da Espressif usando o Framework IDF, a partir desse artigo podemos replicar para as demais fam\u00edlias do ESP32, estes conceitos podem ser levados tamb\u00e9m para trabalharmos com outros microcontroladores que utilizem C e uma programa\u00e7\u00e3o mais abstrata. Este artigo visa no estudo do perif\u00e9rico ADC, ao final deste projeto \u00e9 poss\u00edvel aprender a utilizar o ADC da Franzininho WiFi para leitura de dados anal\u00f3gicos e lhe dar\u00e1 o desafio de aplicar esse aprendizado na leitura de sensores anal\u00f3gicos para voc\u00ea aplicar em seus projetos utilizando o ESP-IDF. Bons estudos. Autor Kayann Soares Data: 01/06/2021","title":"Conclus\u00e3o"},{"location":"about/","text":"Sobre","title":"Sobre"},{"location":"about/#sobre","text":"","title":"Sobre"}]}